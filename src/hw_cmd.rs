//! Generated by Copilet from the esp_idf framework
//!
//! Rust equivalent of the C `sdmmc_hw_cmd_s` bitfield (32-bit command register).
//!
//! This file exposes a transparent `SdmmcHwCmd` newtype around `u32` with
//! typed getters/setters for every field from the original C structure.
//! Using a u32 newtype keeps the representation equal to the original 32-bit
//! register and makes it trivial to read/write the raw register value.

#![allow(non_snake_case)]

use core::fmt;

#[repr(transparent)]
#[derive(Copy, Clone, PartialEq, Eq, Default)]
pub struct SdmmcHwCmd(pub u32);

impl SdmmcHwCmd {
    // bit positions and masks
    const CMD_INDEX_SHIFT: u32 = 0;
    const CMD_INDEX_MASK: u32 = 0x3F << Self::CMD_INDEX_SHIFT; // 6 bits

    const RESPONSE_EXPECT_SHIFT: u32 = 6;
    const RESPONSE_EXPECT_MASK: u32 = 0x1 << Self::RESPONSE_EXPECT_SHIFT;

    const RESPONSE_LONG_SHIFT: u32 = 7;
    const RESPONSE_LONG_MASK: u32 = 0x1 << Self::RESPONSE_LONG_SHIFT;

    const CHECK_RESPONSE_CRC_SHIFT: u32 = 8;
    const CHECK_RESPONSE_CRC_MASK: u32 = 0x1 << Self::CHECK_RESPONSE_CRC_SHIFT;

    const DATA_EXPECTED_SHIFT: u32 = 9;
    const DATA_EXPECTED_MASK: u32 = 0x1 << Self::DATA_EXPECTED_SHIFT;

    const RW_SHIFT: u32 = 10;
    const RW_MASK: u32 = 0x1 << Self::RW_SHIFT;

    const STREAM_MODE_SHIFT: u32 = 11;
    const STREAM_MODE_MASK: u32 = 0x1 << Self::STREAM_MODE_SHIFT;

    const SEND_AUTO_STOP_SHIFT: u32 = 12;
    const SEND_AUTO_STOP_MASK: u32 = 0x1 << Self::SEND_AUTO_STOP_SHIFT;

    const WAIT_COMPLETE_SHIFT: u32 = 13;
    const WAIT_COMPLETE_MASK: u32 = 0x1 << Self::WAIT_COMPLETE_SHIFT;

    const STOP_ABORT_CMD_SHIFT: u32 = 14;
    const STOP_ABORT_CMD_MASK: u32 = 0x1 << Self::STOP_ABORT_CMD_SHIFT;

    const SEND_INIT_SHIFT: u32 = 15;
    const SEND_INIT_MASK: u32 = 0x1 << Self::SEND_INIT_SHIFT;

    const CARD_NUM_SHIFT: u32 = 16;
    const CARD_NUM_MASK: u32 = 0x1F << Self::CARD_NUM_SHIFT; // 5 bits

    const UPDATE_CLK_REG_SHIFT: u32 = 21;
    const UPDATE_CLK_REG_MASK: u32 = 0x1 << Self::UPDATE_CLK_REG_SHIFT;

    const READ_CEATA_SHIFT: u32 = 22;
    const READ_CEATA_MASK: u32 = 0x1 << Self::READ_CEATA_SHIFT;

    const CCS_EXPECTED_SHIFT: u32 = 23;
    const CCS_EXPECTED_MASK: u32 = 0x1 << Self::CCS_EXPECTED_SHIFT;

    const ENABLE_BOOT_SHIFT: u32 = 24;
    const ENABLE_BOOT_MASK: u32 = 0x1 << Self::ENABLE_BOOT_SHIFT;

    const EXPECT_BOOT_ACK_SHIFT: u32 = 25;
    const EXPECT_BOOT_ACK_MASK: u32 = 0x1 << Self::EXPECT_BOOT_ACK_SHIFT;

    const DISABLE_BOOT_SHIFT: u32 = 26;
    const DISABLE_BOOT_MASK: u32 = 0x1 << Self::DISABLE_BOOT_SHIFT;

    const BOOT_MODE_SHIFT: u32 = 27;
    const BOOT_MODE_MASK: u32 = 0x1 << Self::BOOT_MODE_SHIFT;

    const VOLT_SWITCH_SHIFT: u32 = 28;
    const VOLT_SWITCH_MASK: u32 = 0x1 << Self::VOLT_SWITCH_SHIFT;

    const USE_HOLD_REG_SHIFT: u32 = 29;
    const USE_HOLD_REG_MASK: u32 = 0x1 << Self::USE_HOLD_REG_SHIFT;

    const RESERVED_SHIFT: u32 = 30;
    const RESERVED_MASK: u32 = 0x1 << Self::RESERVED_SHIFT;

    const START_COMMAND_SHIFT: u32 = 31;
    const START_COMMAND_MASK: u32 = 0x1 << Self::START_COMMAND_SHIFT;

    /// Construct a zeroed command.
    #[inline]
    pub const fn new() -> Self {
        SdmmcHwCmd(0)
    }

    /// Construct from raw `u32` register value.
    #[inline]
    pub const fn from_raw(raw: u32) -> Self {
        SdmmcHwCmd(raw)
    }

    /// Return raw `u32` register value.
    #[inline]
    pub const fn raw(self) -> u32 {
        self.0
    }

    // --- getters ---

    #[inline]
    pub fn cmd_index(self) -> u8 {
        ((self.0 & Self::CMD_INDEX_MASK) >> Self::CMD_INDEX_SHIFT) as u8
    }

    #[inline]
    pub fn response_expect(self) -> bool {
        (self.0 & Self::RESPONSE_EXPECT_MASK) != 0
    }

    #[inline]
    pub fn response_long(self) -> bool {
        (self.0 & Self::RESPONSE_LONG_MASK) != 0
    }

    #[inline]
    pub fn check_response_crc(self) -> bool {
        (self.0 & Self::CHECK_RESPONSE_CRC_MASK) != 0
    }

    #[inline]
    pub fn data_expected(self) -> bool {
        (self.0 & Self::DATA_EXPECTED_MASK) != 0
    }

    #[inline]
    pub fn rw(self) -> bool {
        (self.0 & Self::RW_MASK) != 0
    }

    #[inline]
    pub fn stream_mode(self) -> bool {
        (self.0 & Self::STREAM_MODE_MASK) != 0
    }

    #[inline]
    pub fn send_auto_stop(self) -> bool {
        (self.0 & Self::SEND_AUTO_STOP_MASK) != 0
    }

    #[inline]
    pub fn wait_complete(self) -> bool {
        (self.0 & Self::WAIT_COMPLETE_MASK) != 0
    }

    #[inline]
    pub fn stop_abort_cmd(self) -> bool {
        (self.0 & Self::STOP_ABORT_CMD_MASK) != 0
    }

    #[inline]
    pub fn send_init(self) -> bool {
        (self.0 & Self::SEND_INIT_MASK) != 0
    }

    #[inline]
    pub fn card_num(self) -> u8 {
        ((self.0 & Self::CARD_NUM_MASK) >> Self::CARD_NUM_SHIFT) as u8
    }

    #[inline]
    pub fn update_clk_reg(self) -> bool {
        (self.0 & Self::UPDATE_CLK_REG_MASK) != 0
    }

    #[inline]
    pub fn read_ceata(self) -> bool {
        (self.0 & Self::READ_CEATA_MASK) != 0
    }

    #[inline]
    pub fn ccs_expected(self) -> bool {
        (self.0 & Self::CCS_EXPECTED_MASK) != 0
    }

    #[inline]
    pub fn enable_boot(self) -> bool {
        (self.0 & Self::ENABLE_BOOT_MASK) != 0
    }

    #[inline]
    pub fn expect_boot_ack(self) -> bool {
        (self.0 & Self::EXPECT_BOOT_ACK_MASK) != 0
    }

    #[inline]
    pub fn disable_boot(self) -> bool {
        (self.0 & Self::DISABLE_BOOT_MASK) != 0
    }

    #[inline]
    pub fn boot_mode(self) -> bool {
        (self.0 & Self::BOOT_MODE_MASK) != 0
    }

    #[inline]
    pub fn volt_switch(self) -> bool {
        (self.0 & Self::VOLT_SWITCH_MASK) != 0
    }

    #[inline]
    pub fn use_hold_reg(self) -> bool {
        (self.0 & Self::USE_HOLD_REG_MASK) != 0
    }

    #[inline]
    pub fn reserved_bit(self) -> bool {
        (self.0 & Self::RESERVED_MASK) != 0
    }

    #[inline]
    pub fn start_command(self) -> bool {
        (self.0 & Self::START_COMMAND_MASK) != 0
    }

    // --- setters (consume & return self for builder-style usage) ---

    #[inline]
    pub fn with_cmd_index(mut self, val: u8) -> Self {
        debug_assert!((val as u32) <= 0x3F, "cmd_index out of range");
        self.0 = (self.0 & !Self::CMD_INDEX_MASK)
            | (((val as u32) << Self::CMD_INDEX_SHIFT) & Self::CMD_INDEX_MASK);
        self
    }

    #[inline]
    pub fn with_response_expect(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::RESPONSE_EXPECT_MASK
        } else {
            self.0 &= !Self::RESPONSE_EXPECT_MASK
        }
        self
    }

    #[inline]
    pub fn with_response_long(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::RESPONSE_LONG_MASK
        } else {
            self.0 &= !Self::RESPONSE_LONG_MASK
        }
        self
    }

    #[inline]
    pub fn with_check_response_crc(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::CHECK_RESPONSE_CRC_MASK
        } else {
            self.0 &= !Self::CHECK_RESPONSE_CRC_MASK
        }
        self
    }

    #[inline]
    pub fn with_data_expected(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::DATA_EXPECTED_MASK
        } else {
            self.0 &= !Self::DATA_EXPECTED_MASK
        }
        self
    }

    #[inline]
    pub fn with_rw(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::RW_MASK
        } else {
            self.0 &= !Self::RW_MASK
        }
        self
    }

    #[inline]
    pub fn with_stream_mode(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::STREAM_MODE_MASK
        } else {
            self.0 &= !Self::STREAM_MODE_MASK
        }
        self
    }

    #[inline]
    pub fn with_send_auto_stop(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::SEND_AUTO_STOP_MASK
        } else {
            self.0 &= !Self::SEND_AUTO_STOP_MASK
        }
        self
    }

    #[inline]
    pub fn with_wait_complete(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::WAIT_COMPLETE_MASK
        } else {
            self.0 &= !Self::WAIT_COMPLETE_MASK
        }
        self
    }

    #[inline]
    pub fn with_stop_abort_cmd(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::STOP_ABORT_CMD_MASK
        } else {
            self.0 &= !Self::STOP_ABORT_CMD_MASK
        }
        self
    }

    #[inline]
    pub fn with_send_init(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::SEND_INIT_MASK
        } else {
            self.0 &= !Self::SEND_INIT_MASK
        }
        self
    }

    #[inline]
    pub fn with_card_num(mut self, val: u8) -> Self {
        debug_assert!((val as u32) <= 0x1F, "card_num out of range");
        self.0 = (self.0 & !Self::CARD_NUM_MASK)
            | (((val as u32) << Self::CARD_NUM_SHIFT) & Self::CARD_NUM_MASK);
        self
    }

    #[inline]
    pub fn with_update_clk_reg(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::UPDATE_CLK_REG_MASK
        } else {
            self.0 &= !Self::UPDATE_CLK_REG_MASK
        }
        self
    }

    #[inline]
    pub fn with_read_ceata(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::READ_CEATA_MASK
        } else {
            self.0 &= !Self::READ_CEATA_MASK
        }
        self
    }

    #[inline]
    pub fn with_ccs_expected(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::CCS_EXPECTED_MASK
        } else {
            self.0 &= !Self::CCS_EXPECTED_MASK
        }
        self
    }

    #[inline]
    pub fn with_enable_boot(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::ENABLE_BOOT_MASK
        } else {
            self.0 &= !Self::ENABLE_BOOT_MASK
        }
        self
    }

    #[inline]
    pub fn with_expect_boot_ack(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::EXPECT_BOOT_ACK_MASK
        } else {
            self.0 &= !Self::EXPECT_BOOT_ACK_MASK
        }
        self
    }

    #[inline]
    pub fn with_disable_boot(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::DISABLE_BOOT_MASK
        } else {
            self.0 &= !Self::DISABLE_BOOT_MASK
        }
        self
    }

    #[inline]
    pub fn with_boot_mode(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::BOOT_MODE_MASK
        } else {
            self.0 &= !Self::BOOT_MODE_MASK
        }
        self
    }

    #[inline]
    pub fn with_volt_switch(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::VOLT_SWITCH_MASK
        } else {
            self.0 &= !Self::VOLT_SWITCH_MASK
        }
        self
    }

    #[inline]
    pub fn with_use_hold_reg(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::USE_HOLD_REG_MASK
        } else {
            self.0 &= !Self::USE_HOLD_REG_MASK
        }
        self
    }

    #[inline]
    pub fn with_start_command(mut self, en: bool) -> Self {
        if en {
            self.0 |= Self::START_COMMAND_MASK
        } else {
            self.0 &= !Self::START_COMMAND_MASK
        }
        self
    }
}

impl From<u32> for SdmmcHwCmd {
    #[inline]
    fn from(v: u32) -> Self {
        SdmmcHwCmd::from_raw(v)
    }
}

impl From<SdmmcHwCmd> for u32 {
    #[inline]
    fn from(cmd: SdmmcHwCmd) -> u32 {
        cmd.raw()
    }
}

impl fmt::Debug for SdmmcHwCmd {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SdmmcHwCmd")
            .field("cmd_index", &self.cmd_index())
            .field("response_expect", &self.response_expect())
            .field("response_long", &self.response_long())
            .field("check_response_crc", &self.check_response_crc())
            .field("data_expected", &self.data_expected())
            .field("rw", &self.rw())
            .field("stream_mode", &self.stream_mode())
            .field("send_auto_stop", &self.send_auto_stop())
            .field("wait_complete", &self.wait_complete())
            .field("stop_abort_cmd", &self.stop_abort_cmd())
            .field("send_init", &self.send_init())
            .field("card_num", &self.card_num())
            .field("update_clk_reg", &self.update_clk_reg())
            .field("read_ceata", &self.read_ceata())
            .field("ccs_expected", &self.ccs_expected())
            .field("enable_boot", &self.enable_boot())
            .field("expect_boot_ack", &self.expect_boot_ack())
            .field("disable_boot", &self.disable_boot())
            .field("boot_mode", &self.boot_mode())
            .field("volt_switch", &self.volt_switch())
            .field("use_hold_reg", &self.use_hold_reg())
            .field("reserved_bit", &self.reserved_bit())
            .field("start_command", &self.start_command())
            .finish()
    }
}
